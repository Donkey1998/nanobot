# Python 浏览器 Agent 方案选型参考（供 AI 使用）

本文档用于为 **AI Agent / LLM** 提供清晰的 Python 浏览器控制方案选型参考，重点对比现有开源库与 **OpenClaw 架构思想** 的契合度，帮助 AI 在设计或调用浏览器工具时做出合理决策。

---

## 一、选型背景与目标

### 背景

* OpenClaw 提供了一套 **Agent-friendly 的浏览器控制架构**（snapshot → act、Profile、多 Driver）。
* 但 OpenClaw 本身是 **TypeScript / Node.js 实现**。
* 在 Agent 生态中，**Python 是主流语言**（LangChain / AutoGen / CrewAI / OpenAI SDK）。

### 目标

* 找到或参考 **Python 生态中可复用的完整/半完整开源方案**
* 支持或接近以下能力：

  * 浏览器自动化（Playwright / CDP）
  * Agent 调用友好（Tool / MCP / snapshot → act）
  * 可扩展为 Browser Control Server

---

## 二、核心评估维度（AI 视角）

AI 在选择浏览器工具时，应重点关注：

1. **是否 Agent-friendly**（非脚本式，而是 Tool 化）
2. **是否支持 snapshot → act 两阶段**
3. **是否支持长期浏览器状态（session / profile）**
4. **是否易于扩展为服务化（HTTP / MCP）**
5. **是否基于 Playwright / CDP（稳定性）**

---

## 三、Python 开源方案对比总览

| 项目                        | Python | Agent 友好度 | snapshot/act | 浏览器后端            | 架构定位               |
| ------------------------- | ------ | --------- | ------------ | ---------------- | ------------------ |
| **browser-use**           | ✅      | ⭐⭐⭐⭐      | ✅            | Playwright       | Agent-first 浏览器工具  |
| **TheAgenticBrowser**     | ✅      | ⭐⭐⭐       | ⚠️（弱）        | Playwright       | 多 Agent workflow   |
| **openbrowser-ai**        | ✅      | ⭐⭐⭐⭐      | ✅            | CDP / Playwright | AI + 浏览器工作流        |
| **agent-browser**         | ✅      | ⭐⭐⭐       | ✅            | Playwright       | MCP Browser Server |
| **agent-stealth-browser** | ✅      | ⭐⭐⭐       | ✅            | Playwright       | MCP + 反检测          |
| **Playwright MCP（官方）**    | ✅      | ⭐⭐⭐⭐      | ✅            | Playwright       | 官方 Agent 协议        |

---

## 四、各方案详细说明

### 1️⃣ browser-use（强烈推荐参考）

**定位**：AI Agent 控制浏览器的 Python 原生库

**特点**：

* 明确以 **LLM / Agent** 为第一使用者
* 内部基于 Playwright
* 支持高层语义操作（navigate / click / fill）

**优点**：

* Agent 友好
* 设计理念接近 OpenClaw 的 act 层

**局限**：

* 更偏“库”，而不是独立 Browser Server
* snapshot 结构化程度有限（需二次封装）

**适合作为**：

* OpenClaw Python 版的 **Driver / Action 层参考**

---

### 2️⃣ TheAgenticBrowser

**定位**：多 Agent 协作的 Web Automation Demo

**特点**：

* Planning / Execution / Critique 多 Agent
* 偏重任务完成而非浏览器架构

**优点**：

* Agent workflow 设计值得参考

**局限**：

* 浏览器控制不是核心
* snapshot / element reference 不稳定

**适合作为**：

* Agent 协作策略参考

---

### 3️⃣ openbrowser-ai

**定位**：AI + 浏览器 + CDP 的综合方案

**特点**：

* 封装 CDP / Playwright
* 提供 AI 驱动的操作抽象

**优点**：

* 功能覆盖较全
* 偏向 OpenClaw 的“浏览器能力聚合”

**局限**：

* 社区相对较小
* 架构可读性一般

**适合作为**：

* OpenClaw Python 替代方案参考

---

### 4️⃣ agent-browser / agent-stealth-browser

**定位**：Python 版 MCP Browser Server

**特点**：

* 实现 MCP（Model Context Protocol）
* 浏览器能力通过标准 Tool 暴露

**优点**：

* **非常接近 OpenClaw 的 Tool Server 思想**
* 天然适合 LLM 调用

**局限**：

* snapshot 语义层较薄
* act 层偏命令式

**适合作为**：

* Python Browser Control Server 的直接参考

---

### 5️⃣ Playwright MCP（官方）

**定位**：官方 Agent ↔ Browser 协议

**特点**：

* snapshot / click / navigate 标准化
* Python 官方支持

**优点**：

* 稳定、长期维护
* 与 LLM Tool 天然对齐

**局限**：

* 偏底层
* 不包含 Profile / 多 Driver 抽象

**适合作为**：

* OpenClaw snapshot/act 的协议级参考

---

## 五、与 OpenClaw 架构的映射关系

| OpenClaw 模块            | Python 参考方案                              |
| ---------------------- | ---------------------------------------- |
| Browser Control Server | agent-browser / FastAPI + Playwright MCP |
| Snapshot (ARIA)        | Playwright accessibility + 自定义封装         |
| Act (click/type)       | browser-use / Playwright MCP             |
| Profile Context        | 自定义 Python 类                             |
| Driver 抽象              | browser-use / openbrowser-ai             |
| Agent Tool             | MCP / LangChain Tool                     |

---

## 六、推荐组合方案（实践向）

### 推荐方案 A（Agent-first，最推荐）

* **FastAPI**：Browser Control Server
* **Playwright (Python)**：浏览器底座
* **Playwright MCP / agent-browser**：Tool 协议
* **自定义 snapshot → act**：对齐 OpenClaw

适合：

* nanobot
* Autonomous Agent
* Research / 产品化

---

### 推荐方案 B（快速落地）

* **browser-use** + LangChain Tool

适合：

* Demo
* PoC
* 内部 Agent

---

## 七、给 AI 的决策指引（Summary for AI）

* **不要把浏览器当脚本**，而是当 Tool Server
* 优先选择支持 **snapshot → act** 的方案
* Python 生态中，**Playwright MCP + agent-browser** 最接近 OpenClaw
* browser-use 是优秀的 Action 层参考
* Profile / Driver 抽象需要自行补齐

> 目标不是复刻 OpenClaw 的代码，而是复刻它的 **Agent-friendly 架构思想**。

---

## 八、结论

Python 生态 **已经具备实现 OpenClaw 架构的全部基础设施**。

OpenClaw ≠ TypeScript

OpenClaw =

* 服务化浏览器
* snapshot → act
* Agent 工具化

这些能力，在 Python 中同样成立。
